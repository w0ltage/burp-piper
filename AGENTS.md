## Project Overview

This is a burp suite extension named "Piper" and written in Kotlin.

Piper integrates external tools and their pipelines to Burp Suite. The extension can pass HTTP requests and responses from Burp to external programs, then feed the execution result back to Burp. With Piper you can create:

- Commentators: Display the output of an external program in Proxy History as comments. For example, you can display the cryptographic hash of every request by piping their content to sha256sum.
- Highlighters: Highlight items in the proxy history based on their contents. For example, you can highlight items where HTTP response includes elements of a wordlist.
- Message Viewers: Display the contents of HTTP messages with custom formatting. For example, you can display Protobuf structures by piping message contents to protoc.
- Context Menu Items: Invoke external tools from context menu. For example, you can use an external diff GUI to compare HTTP messages.
- Intruder Payload Generators: Generate payloads for Intruder with external tools. For example, you can make Intruder use password candidates generated by John the Ripper.
- Intruder Payload Processors: Transform Intruder payloads. For example, you can apply base64 encoding with a custom alphabet using an external script.
- Macros: You can use external tools as part of Macros. For example, you can automatically generate predictable CSRF tokens for every outgoing request.
- HTTP Listeners: Transform outgoing and incoming HTTP messages. For example, you can use an external Python script to handle custom encryption.

## Build & Packaging
- Always build with `./gradlew --no-daemon --console=plain clean shadowJar` so the bundled artifact includes the Kotlin runtime.
- The distributable lives at `build/libs/auto-file-checker-<version>.jar`. Use this JAR when loading the extension into Burp Suite.
- The plain `jar` task is disabled; do not re-enable it unless you provide an alternative way to supply the Kotlin stdlib.


## Kotlin Implementation Notes
- Follow idiomatic Kotlin style (use `data class`, `sealed` hierarchies, and null-safety instead of Java-style optional handling).
- Prefer immutable collections from `kotlin.collections` unless mutation is required for Montoya callbacks.
- Use coroutines only if you wire them into Montoya's threading expectations; current async work relies on Java executors via Kotlin interop.
- Keep UI code on the Swing EDT by wrapping updates with `SwingUtilities.invokeLater { ... }`.

## Montoya API Access
Because direct MCP access is unavailable, fetch Montoya API documentation via HTTP GET requests to Context7 when you need clarification.

**Endpoint template**
```
https://context7.com/api/v1/portswigger/burp-extensions-montoya-api?type=json&tokens=100000&topic=<TOPIC>
```

**Usage guidelines**
- Form topics with 2–4 technical keywords (e.g., `ui%20suite%20tab`, `http%20request%20builder`).
- Query before changing Montoya-dependent logic or when encountering compilation errors tied to Montoya classes.
- Parse the JSON response and extract method signatures or examples relevant to the task at hand.
- Retry with refined terms if the response lacks the needed details.

## Logging & Diagnostics
- Use `api.logging().logToOutput()` for informational messages and `logToError()` for failures.
- Prefer structured log prefixes (e.g., `[AutoChecker]`) so Burp users can filter messages.
- Async errors should be routed through the logging API within completion handlers.

## Compatibility & Dependencies
- Kotlin JVM toolchain pinned to 21—keep it aligned with the Burp Suite runtime.
- Montoya API dependency is `net.portswigger.burp.extensions:montoya-api:2025.4`; update in lockstep with Burp releases and test against the latest Montoya SDK.
- Avoid adding extra dependencies unless absolutely necessary; bundle everything through the shadow JAR to prevent classpath issues for users.
